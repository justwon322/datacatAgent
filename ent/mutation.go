// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"datacatAgent/ent/categorymain"
	"datacatAgent/ent/categorysub"
	"datacatAgent/ent/executionlog"
	"datacatAgent/ent/job"
	"datacatAgent/ent/message"
	"datacatAgent/ent/messagemail"
	"datacatAgent/ent/predicate"
	"datacatAgent/ent/script"
	"datacatAgent/ent/user"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeCategoryMain = "CategoryMain"
	TypeCategorySub  = "CategorySub"
	TypeExecutionLog = "ExecutionLog"
	TypeJob          = "Job"
	TypeMessage      = "Message"
	TypeMessageMail  = "MessageMail"
	TypeScript       = "Script"
	TypeUser         = "User"
)

// CategoryMainMutation represents an operation that mutates the CategoryMain nodes in the graph.
type CategoryMainMutation struct {
	config
	op             Op
	typ            string
	id             *int32
	program        *string
	updatedAt      *time.Time
	createdAt      *time.Time
	name           *string
	priority       *int
	addpriority    *int
	updatedById    *int
	addupdatedById *int
	createdById    *int
	addcreatedById *int
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*CategoryMain, error)
	predicates     []predicate.CategoryMain
}

var _ ent.Mutation = (*CategoryMainMutation)(nil)

// categorymainOption allows management of the mutation configuration using functional options.
type categorymainOption func(*CategoryMainMutation)

// newCategoryMainMutation creates new mutation for the CategoryMain entity.
func newCategoryMainMutation(c config, op Op, opts ...categorymainOption) *CategoryMainMutation {
	m := &CategoryMainMutation{
		config:        c,
		op:            op,
		typ:           TypeCategoryMain,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCategoryMainID sets the ID field of the mutation.
func withCategoryMainID(id int32) categorymainOption {
	return func(m *CategoryMainMutation) {
		var (
			err   error
			once  sync.Once
			value *CategoryMain
		)
		m.oldValue = func(ctx context.Context) (*CategoryMain, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CategoryMain.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCategoryMain sets the old CategoryMain of the mutation.
func withCategoryMain(node *CategoryMain) categorymainOption {
	return func(m *CategoryMainMutation) {
		m.oldValue = func(context.Context) (*CategoryMain, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CategoryMainMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CategoryMainMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CategoryMain entities.
func (m *CategoryMainMutation) SetID(id int32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CategoryMainMutation) ID() (id int32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CategoryMainMutation) IDs(ctx context.Context) ([]int32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CategoryMain.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetProgram sets the "program" field.
func (m *CategoryMainMutation) SetProgram(s string) {
	m.program = &s
}

// Program returns the value of the "program" field in the mutation.
func (m *CategoryMainMutation) Program() (r string, exists bool) {
	v := m.program
	if v == nil {
		return
	}
	return *v, true
}

// OldProgram returns the old "program" field's value of the CategoryMain entity.
// If the CategoryMain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMainMutation) OldProgram(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProgram is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProgram requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProgram: %w", err)
	}
	return oldValue.Program, nil
}

// ResetProgram resets all changes to the "program" field.
func (m *CategoryMainMutation) ResetProgram() {
	m.program = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *CategoryMainMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *CategoryMainMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the CategoryMain entity.
// If the CategoryMain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMainMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *CategoryMainMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetCreatedAt sets the "createdAt" field.
func (m *CategoryMainMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *CategoryMainMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the CategoryMain entity.
// If the CategoryMain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMainMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *CategoryMainMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetName sets the "name" field.
func (m *CategoryMainMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CategoryMainMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the CategoryMain entity.
// If the CategoryMain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMainMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CategoryMainMutation) ResetName() {
	m.name = nil
}

// SetPriority sets the "priority" field.
func (m *CategoryMainMutation) SetPriority(i int) {
	m.priority = &i
	m.addpriority = nil
}

// Priority returns the value of the "priority" field in the mutation.
func (m *CategoryMainMutation) Priority() (r int, exists bool) {
	v := m.priority
	if v == nil {
		return
	}
	return *v, true
}

// OldPriority returns the old "priority" field's value of the CategoryMain entity.
// If the CategoryMain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMainMutation) OldPriority(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriority: %w", err)
	}
	return oldValue.Priority, nil
}

// AddPriority adds i to the "priority" field.
func (m *CategoryMainMutation) AddPriority(i int) {
	if m.addpriority != nil {
		*m.addpriority += i
	} else {
		m.addpriority = &i
	}
}

// AddedPriority returns the value that was added to the "priority" field in this mutation.
func (m *CategoryMainMutation) AddedPriority() (r int, exists bool) {
	v := m.addpriority
	if v == nil {
		return
	}
	return *v, true
}

// ResetPriority resets all changes to the "priority" field.
func (m *CategoryMainMutation) ResetPriority() {
	m.priority = nil
	m.addpriority = nil
}

// SetUpdatedById sets the "updatedById" field.
func (m *CategoryMainMutation) SetUpdatedById(i int) {
	m.updatedById = &i
	m.addupdatedById = nil
}

// UpdatedById returns the value of the "updatedById" field in the mutation.
func (m *CategoryMainMutation) UpdatedById() (r int, exists bool) {
	v := m.updatedById
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedById returns the old "updatedById" field's value of the CategoryMain entity.
// If the CategoryMain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMainMutation) OldUpdatedById(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedById is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedById requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedById: %w", err)
	}
	return oldValue.UpdatedById, nil
}

// AddUpdatedById adds i to the "updatedById" field.
func (m *CategoryMainMutation) AddUpdatedById(i int) {
	if m.addupdatedById != nil {
		*m.addupdatedById += i
	} else {
		m.addupdatedById = &i
	}
}

// AddedUpdatedById returns the value that was added to the "updatedById" field in this mutation.
func (m *CategoryMainMutation) AddedUpdatedById() (r int, exists bool) {
	v := m.addupdatedById
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedById resets all changes to the "updatedById" field.
func (m *CategoryMainMutation) ResetUpdatedById() {
	m.updatedById = nil
	m.addupdatedById = nil
}

// SetCreatedById sets the "createdById" field.
func (m *CategoryMainMutation) SetCreatedById(i int) {
	m.createdById = &i
	m.addcreatedById = nil
}

// CreatedById returns the value of the "createdById" field in the mutation.
func (m *CategoryMainMutation) CreatedById() (r int, exists bool) {
	v := m.createdById
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedById returns the old "createdById" field's value of the CategoryMain entity.
// If the CategoryMain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMainMutation) OldCreatedById(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedById is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedById requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedById: %w", err)
	}
	return oldValue.CreatedById, nil
}

// AddCreatedById adds i to the "createdById" field.
func (m *CategoryMainMutation) AddCreatedById(i int) {
	if m.addcreatedById != nil {
		*m.addcreatedById += i
	} else {
		m.addcreatedById = &i
	}
}

// AddedCreatedById returns the value that was added to the "createdById" field in this mutation.
func (m *CategoryMainMutation) AddedCreatedById() (r int, exists bool) {
	v := m.addcreatedById
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedById resets all changes to the "createdById" field.
func (m *CategoryMainMutation) ResetCreatedById() {
	m.createdById = nil
	m.addcreatedById = nil
}

// Where appends a list predicates to the CategoryMainMutation builder.
func (m *CategoryMainMutation) Where(ps ...predicate.CategoryMain) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CategoryMainMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CategoryMainMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CategoryMain, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CategoryMainMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CategoryMainMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CategoryMain).
func (m *CategoryMainMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CategoryMainMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.program != nil {
		fields = append(fields, categorymain.FieldProgram)
	}
	if m.updatedAt != nil {
		fields = append(fields, categorymain.FieldUpdatedAt)
	}
	if m.createdAt != nil {
		fields = append(fields, categorymain.FieldCreatedAt)
	}
	if m.name != nil {
		fields = append(fields, categorymain.FieldName)
	}
	if m.priority != nil {
		fields = append(fields, categorymain.FieldPriority)
	}
	if m.updatedById != nil {
		fields = append(fields, categorymain.FieldUpdatedById)
	}
	if m.createdById != nil {
		fields = append(fields, categorymain.FieldCreatedById)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CategoryMainMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case categorymain.FieldProgram:
		return m.Program()
	case categorymain.FieldUpdatedAt:
		return m.UpdatedAt()
	case categorymain.FieldCreatedAt:
		return m.CreatedAt()
	case categorymain.FieldName:
		return m.Name()
	case categorymain.FieldPriority:
		return m.Priority()
	case categorymain.FieldUpdatedById:
		return m.UpdatedById()
	case categorymain.FieldCreatedById:
		return m.CreatedById()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CategoryMainMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case categorymain.FieldProgram:
		return m.OldProgram(ctx)
	case categorymain.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case categorymain.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case categorymain.FieldName:
		return m.OldName(ctx)
	case categorymain.FieldPriority:
		return m.OldPriority(ctx)
	case categorymain.FieldUpdatedById:
		return m.OldUpdatedById(ctx)
	case categorymain.FieldCreatedById:
		return m.OldCreatedById(ctx)
	}
	return nil, fmt.Errorf("unknown CategoryMain field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CategoryMainMutation) SetField(name string, value ent.Value) error {
	switch name {
	case categorymain.FieldProgram:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProgram(v)
		return nil
	case categorymain.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case categorymain.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case categorymain.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case categorymain.FieldPriority:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriority(v)
		return nil
	case categorymain.FieldUpdatedById:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedById(v)
		return nil
	case categorymain.FieldCreatedById:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedById(v)
		return nil
	}
	return fmt.Errorf("unknown CategoryMain field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CategoryMainMutation) AddedFields() []string {
	var fields []string
	if m.addpriority != nil {
		fields = append(fields, categorymain.FieldPriority)
	}
	if m.addupdatedById != nil {
		fields = append(fields, categorymain.FieldUpdatedById)
	}
	if m.addcreatedById != nil {
		fields = append(fields, categorymain.FieldCreatedById)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CategoryMainMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case categorymain.FieldPriority:
		return m.AddedPriority()
	case categorymain.FieldUpdatedById:
		return m.AddedUpdatedById()
	case categorymain.FieldCreatedById:
		return m.AddedCreatedById()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CategoryMainMutation) AddField(name string, value ent.Value) error {
	switch name {
	case categorymain.FieldPriority:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPriority(v)
		return nil
	case categorymain.FieldUpdatedById:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedById(v)
		return nil
	case categorymain.FieldCreatedById:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedById(v)
		return nil
	}
	return fmt.Errorf("unknown CategoryMain numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CategoryMainMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CategoryMainMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CategoryMainMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CategoryMain nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CategoryMainMutation) ResetField(name string) error {
	switch name {
	case categorymain.FieldProgram:
		m.ResetProgram()
		return nil
	case categorymain.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case categorymain.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case categorymain.FieldName:
		m.ResetName()
		return nil
	case categorymain.FieldPriority:
		m.ResetPriority()
		return nil
	case categorymain.FieldUpdatedById:
		m.ResetUpdatedById()
		return nil
	case categorymain.FieldCreatedById:
		m.ResetCreatedById()
		return nil
	}
	return fmt.Errorf("unknown CategoryMain field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CategoryMainMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CategoryMainMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CategoryMainMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CategoryMainMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CategoryMainMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CategoryMainMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CategoryMainMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CategoryMain unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CategoryMainMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CategoryMain edge %s", name)
}

// CategorySubMutation represents an operation that mutates the CategorySub nodes in the graph.
type CategorySubMutation struct {
	config
	op                Op
	typ               string
	id                *int32
	program           *string
	updatedAt         *time.Time
	createdAt         *time.Time
	name              *string
	updatedById       *int
	addupdatedById    *int
	createdById       *int
	addcreatedById    *int
	categoryMainId    *int32
	addcategoryMainId *int32
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*CategorySub, error)
	predicates        []predicate.CategorySub
}

var _ ent.Mutation = (*CategorySubMutation)(nil)

// categorysubOption allows management of the mutation configuration using functional options.
type categorysubOption func(*CategorySubMutation)

// newCategorySubMutation creates new mutation for the CategorySub entity.
func newCategorySubMutation(c config, op Op, opts ...categorysubOption) *CategorySubMutation {
	m := &CategorySubMutation{
		config:        c,
		op:            op,
		typ:           TypeCategorySub,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCategorySubID sets the ID field of the mutation.
func withCategorySubID(id int32) categorysubOption {
	return func(m *CategorySubMutation) {
		var (
			err   error
			once  sync.Once
			value *CategorySub
		)
		m.oldValue = func(ctx context.Context) (*CategorySub, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CategorySub.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCategorySub sets the old CategorySub of the mutation.
func withCategorySub(node *CategorySub) categorysubOption {
	return func(m *CategorySubMutation) {
		m.oldValue = func(context.Context) (*CategorySub, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CategorySubMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CategorySubMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CategorySub entities.
func (m *CategorySubMutation) SetID(id int32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CategorySubMutation) ID() (id int32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CategorySubMutation) IDs(ctx context.Context) ([]int32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CategorySub.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetProgram sets the "program" field.
func (m *CategorySubMutation) SetProgram(s string) {
	m.program = &s
}

// Program returns the value of the "program" field in the mutation.
func (m *CategorySubMutation) Program() (r string, exists bool) {
	v := m.program
	if v == nil {
		return
	}
	return *v, true
}

// OldProgram returns the old "program" field's value of the CategorySub entity.
// If the CategorySub object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategorySubMutation) OldProgram(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProgram is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProgram requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProgram: %w", err)
	}
	return oldValue.Program, nil
}

// ResetProgram resets all changes to the "program" field.
func (m *CategorySubMutation) ResetProgram() {
	m.program = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *CategorySubMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *CategorySubMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the CategorySub entity.
// If the CategorySub object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategorySubMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *CategorySubMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetCreatedAt sets the "createdAt" field.
func (m *CategorySubMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *CategorySubMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the CategorySub entity.
// If the CategorySub object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategorySubMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *CategorySubMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetName sets the "name" field.
func (m *CategorySubMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CategorySubMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the CategorySub entity.
// If the CategorySub object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategorySubMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CategorySubMutation) ResetName() {
	m.name = nil
}

// SetUpdatedById sets the "updatedById" field.
func (m *CategorySubMutation) SetUpdatedById(i int) {
	m.updatedById = &i
	m.addupdatedById = nil
}

// UpdatedById returns the value of the "updatedById" field in the mutation.
func (m *CategorySubMutation) UpdatedById() (r int, exists bool) {
	v := m.updatedById
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedById returns the old "updatedById" field's value of the CategorySub entity.
// If the CategorySub object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategorySubMutation) OldUpdatedById(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedById is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedById requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedById: %w", err)
	}
	return oldValue.UpdatedById, nil
}

// AddUpdatedById adds i to the "updatedById" field.
func (m *CategorySubMutation) AddUpdatedById(i int) {
	if m.addupdatedById != nil {
		*m.addupdatedById += i
	} else {
		m.addupdatedById = &i
	}
}

// AddedUpdatedById returns the value that was added to the "updatedById" field in this mutation.
func (m *CategorySubMutation) AddedUpdatedById() (r int, exists bool) {
	v := m.addupdatedById
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedById resets all changes to the "updatedById" field.
func (m *CategorySubMutation) ResetUpdatedById() {
	m.updatedById = nil
	m.addupdatedById = nil
}

// SetCreatedById sets the "createdById" field.
func (m *CategorySubMutation) SetCreatedById(i int) {
	m.createdById = &i
	m.addcreatedById = nil
}

// CreatedById returns the value of the "createdById" field in the mutation.
func (m *CategorySubMutation) CreatedById() (r int, exists bool) {
	v := m.createdById
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedById returns the old "createdById" field's value of the CategorySub entity.
// If the CategorySub object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategorySubMutation) OldCreatedById(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedById is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedById requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedById: %w", err)
	}
	return oldValue.CreatedById, nil
}

// AddCreatedById adds i to the "createdById" field.
func (m *CategorySubMutation) AddCreatedById(i int) {
	if m.addcreatedById != nil {
		*m.addcreatedById += i
	} else {
		m.addcreatedById = &i
	}
}

// AddedCreatedById returns the value that was added to the "createdById" field in this mutation.
func (m *CategorySubMutation) AddedCreatedById() (r int, exists bool) {
	v := m.addcreatedById
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedById resets all changes to the "createdById" field.
func (m *CategorySubMutation) ResetCreatedById() {
	m.createdById = nil
	m.addcreatedById = nil
}

// SetCategoryMainId sets the "categoryMainId" field.
func (m *CategorySubMutation) SetCategoryMainId(i int32) {
	m.categoryMainId = &i
	m.addcategoryMainId = nil
}

// CategoryMainId returns the value of the "categoryMainId" field in the mutation.
func (m *CategorySubMutation) CategoryMainId() (r int32, exists bool) {
	v := m.categoryMainId
	if v == nil {
		return
	}
	return *v, true
}

// OldCategoryMainId returns the old "categoryMainId" field's value of the CategorySub entity.
// If the CategorySub object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategorySubMutation) OldCategoryMainId(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategoryMainId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategoryMainId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategoryMainId: %w", err)
	}
	return oldValue.CategoryMainId, nil
}

// AddCategoryMainId adds i to the "categoryMainId" field.
func (m *CategorySubMutation) AddCategoryMainId(i int32) {
	if m.addcategoryMainId != nil {
		*m.addcategoryMainId += i
	} else {
		m.addcategoryMainId = &i
	}
}

// AddedCategoryMainId returns the value that was added to the "categoryMainId" field in this mutation.
func (m *CategorySubMutation) AddedCategoryMainId() (r int32, exists bool) {
	v := m.addcategoryMainId
	if v == nil {
		return
	}
	return *v, true
}

// ResetCategoryMainId resets all changes to the "categoryMainId" field.
func (m *CategorySubMutation) ResetCategoryMainId() {
	m.categoryMainId = nil
	m.addcategoryMainId = nil
}

// Where appends a list predicates to the CategorySubMutation builder.
func (m *CategorySubMutation) Where(ps ...predicate.CategorySub) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CategorySubMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CategorySubMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CategorySub, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CategorySubMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CategorySubMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CategorySub).
func (m *CategorySubMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CategorySubMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.program != nil {
		fields = append(fields, categorysub.FieldProgram)
	}
	if m.updatedAt != nil {
		fields = append(fields, categorysub.FieldUpdatedAt)
	}
	if m.createdAt != nil {
		fields = append(fields, categorysub.FieldCreatedAt)
	}
	if m.name != nil {
		fields = append(fields, categorysub.FieldName)
	}
	if m.updatedById != nil {
		fields = append(fields, categorysub.FieldUpdatedById)
	}
	if m.createdById != nil {
		fields = append(fields, categorysub.FieldCreatedById)
	}
	if m.categoryMainId != nil {
		fields = append(fields, categorysub.FieldCategoryMainId)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CategorySubMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case categorysub.FieldProgram:
		return m.Program()
	case categorysub.FieldUpdatedAt:
		return m.UpdatedAt()
	case categorysub.FieldCreatedAt:
		return m.CreatedAt()
	case categorysub.FieldName:
		return m.Name()
	case categorysub.FieldUpdatedById:
		return m.UpdatedById()
	case categorysub.FieldCreatedById:
		return m.CreatedById()
	case categorysub.FieldCategoryMainId:
		return m.CategoryMainId()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CategorySubMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case categorysub.FieldProgram:
		return m.OldProgram(ctx)
	case categorysub.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case categorysub.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case categorysub.FieldName:
		return m.OldName(ctx)
	case categorysub.FieldUpdatedById:
		return m.OldUpdatedById(ctx)
	case categorysub.FieldCreatedById:
		return m.OldCreatedById(ctx)
	case categorysub.FieldCategoryMainId:
		return m.OldCategoryMainId(ctx)
	}
	return nil, fmt.Errorf("unknown CategorySub field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CategorySubMutation) SetField(name string, value ent.Value) error {
	switch name {
	case categorysub.FieldProgram:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProgram(v)
		return nil
	case categorysub.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case categorysub.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case categorysub.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case categorysub.FieldUpdatedById:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedById(v)
		return nil
	case categorysub.FieldCreatedById:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedById(v)
		return nil
	case categorysub.FieldCategoryMainId:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategoryMainId(v)
		return nil
	}
	return fmt.Errorf("unknown CategorySub field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CategorySubMutation) AddedFields() []string {
	var fields []string
	if m.addupdatedById != nil {
		fields = append(fields, categorysub.FieldUpdatedById)
	}
	if m.addcreatedById != nil {
		fields = append(fields, categorysub.FieldCreatedById)
	}
	if m.addcategoryMainId != nil {
		fields = append(fields, categorysub.FieldCategoryMainId)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CategorySubMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case categorysub.FieldUpdatedById:
		return m.AddedUpdatedById()
	case categorysub.FieldCreatedById:
		return m.AddedCreatedById()
	case categorysub.FieldCategoryMainId:
		return m.AddedCategoryMainId()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CategorySubMutation) AddField(name string, value ent.Value) error {
	switch name {
	case categorysub.FieldUpdatedById:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedById(v)
		return nil
	case categorysub.FieldCreatedById:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedById(v)
		return nil
	case categorysub.FieldCategoryMainId:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCategoryMainId(v)
		return nil
	}
	return fmt.Errorf("unknown CategorySub numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CategorySubMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CategorySubMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CategorySubMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CategorySub nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CategorySubMutation) ResetField(name string) error {
	switch name {
	case categorysub.FieldProgram:
		m.ResetProgram()
		return nil
	case categorysub.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case categorysub.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case categorysub.FieldName:
		m.ResetName()
		return nil
	case categorysub.FieldUpdatedById:
		m.ResetUpdatedById()
		return nil
	case categorysub.FieldCreatedById:
		m.ResetCreatedById()
		return nil
	case categorysub.FieldCategoryMainId:
		m.ResetCategoryMainId()
		return nil
	}
	return fmt.Errorf("unknown CategorySub field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CategorySubMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CategorySubMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CategorySubMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CategorySubMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CategorySubMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CategorySubMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CategorySubMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CategorySub unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CategorySubMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CategorySub edge %s", name)
}

// ExecutionLogMutation represents an operation that mutates the ExecutionLog nodes in the graph.
type ExecutionLogMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	status        *int
	addstatus     *int
	result        *string
	executedAt    *time.Time
	scriptId      *int
	addscriptId   *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*ExecutionLog, error)
	predicates    []predicate.ExecutionLog
}

var _ ent.Mutation = (*ExecutionLogMutation)(nil)

// executionlogOption allows management of the mutation configuration using functional options.
type executionlogOption func(*ExecutionLogMutation)

// newExecutionLogMutation creates new mutation for the ExecutionLog entity.
func newExecutionLogMutation(c config, op Op, opts ...executionlogOption) *ExecutionLogMutation {
	m := &ExecutionLogMutation{
		config:        c,
		op:            op,
		typ:           TypeExecutionLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withExecutionLogID sets the ID field of the mutation.
func withExecutionLogID(id int64) executionlogOption {
	return func(m *ExecutionLogMutation) {
		var (
			err   error
			once  sync.Once
			value *ExecutionLog
		)
		m.oldValue = func(ctx context.Context) (*ExecutionLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ExecutionLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withExecutionLog sets the old ExecutionLog of the mutation.
func withExecutionLog(node *ExecutionLog) executionlogOption {
	return func(m *ExecutionLogMutation) {
		m.oldValue = func(context.Context) (*ExecutionLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ExecutionLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ExecutionLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ExecutionLog entities.
func (m *ExecutionLogMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ExecutionLogMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ExecutionLogMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ExecutionLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetStatus sets the "status" field.
func (m *ExecutionLogMutation) SetStatus(i int) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *ExecutionLogMutation) Status() (r int, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ExecutionLog entity.
// If the ExecutionLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExecutionLogMutation) OldStatus(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *ExecutionLogMutation) AddStatus(i int) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *ExecutionLogMutation) AddedStatus() (r int, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *ExecutionLogMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetResult sets the "result" field.
func (m *ExecutionLogMutation) SetResult(s string) {
	m.result = &s
}

// Result returns the value of the "result" field in the mutation.
func (m *ExecutionLogMutation) Result() (r string, exists bool) {
	v := m.result
	if v == nil {
		return
	}
	return *v, true
}

// OldResult returns the old "result" field's value of the ExecutionLog entity.
// If the ExecutionLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExecutionLogMutation) OldResult(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResult is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResult requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResult: %w", err)
	}
	return oldValue.Result, nil
}

// ResetResult resets all changes to the "result" field.
func (m *ExecutionLogMutation) ResetResult() {
	m.result = nil
}

// SetExecutedAt sets the "executedAt" field.
func (m *ExecutionLogMutation) SetExecutedAt(t time.Time) {
	m.executedAt = &t
}

// ExecutedAt returns the value of the "executedAt" field in the mutation.
func (m *ExecutionLogMutation) ExecutedAt() (r time.Time, exists bool) {
	v := m.executedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldExecutedAt returns the old "executedAt" field's value of the ExecutionLog entity.
// If the ExecutionLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExecutionLogMutation) OldExecutedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExecutedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExecutedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExecutedAt: %w", err)
	}
	return oldValue.ExecutedAt, nil
}

// ResetExecutedAt resets all changes to the "executedAt" field.
func (m *ExecutionLogMutation) ResetExecutedAt() {
	m.executedAt = nil
}

// SetScriptId sets the "scriptId" field.
func (m *ExecutionLogMutation) SetScriptId(i int) {
	m.scriptId = &i
	m.addscriptId = nil
}

// ScriptId returns the value of the "scriptId" field in the mutation.
func (m *ExecutionLogMutation) ScriptId() (r int, exists bool) {
	v := m.scriptId
	if v == nil {
		return
	}
	return *v, true
}

// OldScriptId returns the old "scriptId" field's value of the ExecutionLog entity.
// If the ExecutionLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExecutionLogMutation) OldScriptId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScriptId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScriptId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScriptId: %w", err)
	}
	return oldValue.ScriptId, nil
}

// AddScriptId adds i to the "scriptId" field.
func (m *ExecutionLogMutation) AddScriptId(i int) {
	if m.addscriptId != nil {
		*m.addscriptId += i
	} else {
		m.addscriptId = &i
	}
}

// AddedScriptId returns the value that was added to the "scriptId" field in this mutation.
func (m *ExecutionLogMutation) AddedScriptId() (r int, exists bool) {
	v := m.addscriptId
	if v == nil {
		return
	}
	return *v, true
}

// ResetScriptId resets all changes to the "scriptId" field.
func (m *ExecutionLogMutation) ResetScriptId() {
	m.scriptId = nil
	m.addscriptId = nil
}

// Where appends a list predicates to the ExecutionLogMutation builder.
func (m *ExecutionLogMutation) Where(ps ...predicate.ExecutionLog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ExecutionLogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ExecutionLogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ExecutionLog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ExecutionLogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ExecutionLogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ExecutionLog).
func (m *ExecutionLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ExecutionLogMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.status != nil {
		fields = append(fields, executionlog.FieldStatus)
	}
	if m.result != nil {
		fields = append(fields, executionlog.FieldResult)
	}
	if m.executedAt != nil {
		fields = append(fields, executionlog.FieldExecutedAt)
	}
	if m.scriptId != nil {
		fields = append(fields, executionlog.FieldScriptId)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ExecutionLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case executionlog.FieldStatus:
		return m.Status()
	case executionlog.FieldResult:
		return m.Result()
	case executionlog.FieldExecutedAt:
		return m.ExecutedAt()
	case executionlog.FieldScriptId:
		return m.ScriptId()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ExecutionLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case executionlog.FieldStatus:
		return m.OldStatus(ctx)
	case executionlog.FieldResult:
		return m.OldResult(ctx)
	case executionlog.FieldExecutedAt:
		return m.OldExecutedAt(ctx)
	case executionlog.FieldScriptId:
		return m.OldScriptId(ctx)
	}
	return nil, fmt.Errorf("unknown ExecutionLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExecutionLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case executionlog.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case executionlog.FieldResult:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResult(v)
		return nil
	case executionlog.FieldExecutedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExecutedAt(v)
		return nil
	case executionlog.FieldScriptId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScriptId(v)
		return nil
	}
	return fmt.Errorf("unknown ExecutionLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ExecutionLogMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, executionlog.FieldStatus)
	}
	if m.addscriptId != nil {
		fields = append(fields, executionlog.FieldScriptId)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ExecutionLogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case executionlog.FieldStatus:
		return m.AddedStatus()
	case executionlog.FieldScriptId:
		return m.AddedScriptId()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExecutionLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	case executionlog.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case executionlog.FieldScriptId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddScriptId(v)
		return nil
	}
	return fmt.Errorf("unknown ExecutionLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ExecutionLogMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ExecutionLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ExecutionLogMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ExecutionLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ExecutionLogMutation) ResetField(name string) error {
	switch name {
	case executionlog.FieldStatus:
		m.ResetStatus()
		return nil
	case executionlog.FieldResult:
		m.ResetResult()
		return nil
	case executionlog.FieldExecutedAt:
		m.ResetExecutedAt()
		return nil
	case executionlog.FieldScriptId:
		m.ResetScriptId()
		return nil
	}
	return fmt.Errorf("unknown ExecutionLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ExecutionLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ExecutionLogMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ExecutionLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ExecutionLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ExecutionLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ExecutionLogMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ExecutionLogMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ExecutionLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ExecutionLogMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ExecutionLog edge %s", name)
}

// JobMutation represents an operation that mutates the Job nodes in the graph.
type JobMutation struct {
	config
	op               Op
	typ              string
	id               *int32
	program          *string
	updatedAt        *time.Time
	createdAt        *time.Time
	name             *string
	updatedById      *int
	addupdatedById   *int
	createdById      *int
	addcreatedById   *int
	categorySubId    *int
	addcategorySubId *int
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*Job, error)
	predicates       []predicate.Job
}

var _ ent.Mutation = (*JobMutation)(nil)

// jobOption allows management of the mutation configuration using functional options.
type jobOption func(*JobMutation)

// newJobMutation creates new mutation for the Job entity.
func newJobMutation(c config, op Op, opts ...jobOption) *JobMutation {
	m := &JobMutation{
		config:        c,
		op:            op,
		typ:           TypeJob,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withJobID sets the ID field of the mutation.
func withJobID(id int32) jobOption {
	return func(m *JobMutation) {
		var (
			err   error
			once  sync.Once
			value *Job
		)
		m.oldValue = func(ctx context.Context) (*Job, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Job.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withJob sets the old Job of the mutation.
func withJob(node *Job) jobOption {
	return func(m *JobMutation) {
		m.oldValue = func(context.Context) (*Job, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m JobMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m JobMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Job entities.
func (m *JobMutation) SetID(id int32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *JobMutation) ID() (id int32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *JobMutation) IDs(ctx context.Context) ([]int32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Job.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetProgram sets the "program" field.
func (m *JobMutation) SetProgram(s string) {
	m.program = &s
}

// Program returns the value of the "program" field in the mutation.
func (m *JobMutation) Program() (r string, exists bool) {
	v := m.program
	if v == nil {
		return
	}
	return *v, true
}

// OldProgram returns the old "program" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldProgram(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProgram is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProgram requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProgram: %w", err)
	}
	return oldValue.Program, nil
}

// ResetProgram resets all changes to the "program" field.
func (m *JobMutation) ResetProgram() {
	m.program = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *JobMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *JobMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *JobMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetCreatedAt sets the "createdAt" field.
func (m *JobMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *JobMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *JobMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetName sets the "name" field.
func (m *JobMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *JobMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *JobMutation) ResetName() {
	m.name = nil
}

// SetUpdatedById sets the "updatedById" field.
func (m *JobMutation) SetUpdatedById(i int) {
	m.updatedById = &i
	m.addupdatedById = nil
}

// UpdatedById returns the value of the "updatedById" field in the mutation.
func (m *JobMutation) UpdatedById() (r int, exists bool) {
	v := m.updatedById
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedById returns the old "updatedById" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldUpdatedById(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedById is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedById requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedById: %w", err)
	}
	return oldValue.UpdatedById, nil
}

// AddUpdatedById adds i to the "updatedById" field.
func (m *JobMutation) AddUpdatedById(i int) {
	if m.addupdatedById != nil {
		*m.addupdatedById += i
	} else {
		m.addupdatedById = &i
	}
}

// AddedUpdatedById returns the value that was added to the "updatedById" field in this mutation.
func (m *JobMutation) AddedUpdatedById() (r int, exists bool) {
	v := m.addupdatedById
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedById resets all changes to the "updatedById" field.
func (m *JobMutation) ResetUpdatedById() {
	m.updatedById = nil
	m.addupdatedById = nil
}

// SetCreatedById sets the "createdById" field.
func (m *JobMutation) SetCreatedById(i int) {
	m.createdById = &i
	m.addcreatedById = nil
}

// CreatedById returns the value of the "createdById" field in the mutation.
func (m *JobMutation) CreatedById() (r int, exists bool) {
	v := m.createdById
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedById returns the old "createdById" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldCreatedById(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedById is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedById requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedById: %w", err)
	}
	return oldValue.CreatedById, nil
}

// AddCreatedById adds i to the "createdById" field.
func (m *JobMutation) AddCreatedById(i int) {
	if m.addcreatedById != nil {
		*m.addcreatedById += i
	} else {
		m.addcreatedById = &i
	}
}

// AddedCreatedById returns the value that was added to the "createdById" field in this mutation.
func (m *JobMutation) AddedCreatedById() (r int, exists bool) {
	v := m.addcreatedById
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedById resets all changes to the "createdById" field.
func (m *JobMutation) ResetCreatedById() {
	m.createdById = nil
	m.addcreatedById = nil
}

// SetCategorySubId sets the "categorySubId" field.
func (m *JobMutation) SetCategorySubId(i int) {
	m.categorySubId = &i
	m.addcategorySubId = nil
}

// CategorySubId returns the value of the "categorySubId" field in the mutation.
func (m *JobMutation) CategorySubId() (r int, exists bool) {
	v := m.categorySubId
	if v == nil {
		return
	}
	return *v, true
}

// OldCategorySubId returns the old "categorySubId" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldCategorySubId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategorySubId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategorySubId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategorySubId: %w", err)
	}
	return oldValue.CategorySubId, nil
}

// AddCategorySubId adds i to the "categorySubId" field.
func (m *JobMutation) AddCategorySubId(i int) {
	if m.addcategorySubId != nil {
		*m.addcategorySubId += i
	} else {
		m.addcategorySubId = &i
	}
}

// AddedCategorySubId returns the value that was added to the "categorySubId" field in this mutation.
func (m *JobMutation) AddedCategorySubId() (r int, exists bool) {
	v := m.addcategorySubId
	if v == nil {
		return
	}
	return *v, true
}

// ResetCategorySubId resets all changes to the "categorySubId" field.
func (m *JobMutation) ResetCategorySubId() {
	m.categorySubId = nil
	m.addcategorySubId = nil
}

// Where appends a list predicates to the JobMutation builder.
func (m *JobMutation) Where(ps ...predicate.Job) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the JobMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *JobMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Job, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *JobMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *JobMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Job).
func (m *JobMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *JobMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.program != nil {
		fields = append(fields, job.FieldProgram)
	}
	if m.updatedAt != nil {
		fields = append(fields, job.FieldUpdatedAt)
	}
	if m.createdAt != nil {
		fields = append(fields, job.FieldCreatedAt)
	}
	if m.name != nil {
		fields = append(fields, job.FieldName)
	}
	if m.updatedById != nil {
		fields = append(fields, job.FieldUpdatedById)
	}
	if m.createdById != nil {
		fields = append(fields, job.FieldCreatedById)
	}
	if m.categorySubId != nil {
		fields = append(fields, job.FieldCategorySubId)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *JobMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case job.FieldProgram:
		return m.Program()
	case job.FieldUpdatedAt:
		return m.UpdatedAt()
	case job.FieldCreatedAt:
		return m.CreatedAt()
	case job.FieldName:
		return m.Name()
	case job.FieldUpdatedById:
		return m.UpdatedById()
	case job.FieldCreatedById:
		return m.CreatedById()
	case job.FieldCategorySubId:
		return m.CategorySubId()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *JobMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case job.FieldProgram:
		return m.OldProgram(ctx)
	case job.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case job.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case job.FieldName:
		return m.OldName(ctx)
	case job.FieldUpdatedById:
		return m.OldUpdatedById(ctx)
	case job.FieldCreatedById:
		return m.OldCreatedById(ctx)
	case job.FieldCategorySubId:
		return m.OldCategorySubId(ctx)
	}
	return nil, fmt.Errorf("unknown Job field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JobMutation) SetField(name string, value ent.Value) error {
	switch name {
	case job.FieldProgram:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProgram(v)
		return nil
	case job.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case job.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case job.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case job.FieldUpdatedById:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedById(v)
		return nil
	case job.FieldCreatedById:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedById(v)
		return nil
	case job.FieldCategorySubId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategorySubId(v)
		return nil
	}
	return fmt.Errorf("unknown Job field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *JobMutation) AddedFields() []string {
	var fields []string
	if m.addupdatedById != nil {
		fields = append(fields, job.FieldUpdatedById)
	}
	if m.addcreatedById != nil {
		fields = append(fields, job.FieldCreatedById)
	}
	if m.addcategorySubId != nil {
		fields = append(fields, job.FieldCategorySubId)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *JobMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case job.FieldUpdatedById:
		return m.AddedUpdatedById()
	case job.FieldCreatedById:
		return m.AddedCreatedById()
	case job.FieldCategorySubId:
		return m.AddedCategorySubId()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JobMutation) AddField(name string, value ent.Value) error {
	switch name {
	case job.FieldUpdatedById:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedById(v)
		return nil
	case job.FieldCreatedById:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedById(v)
		return nil
	case job.FieldCategorySubId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCategorySubId(v)
		return nil
	}
	return fmt.Errorf("unknown Job numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *JobMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *JobMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *JobMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Job nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *JobMutation) ResetField(name string) error {
	switch name {
	case job.FieldProgram:
		m.ResetProgram()
		return nil
	case job.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case job.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case job.FieldName:
		m.ResetName()
		return nil
	case job.FieldUpdatedById:
		m.ResetUpdatedById()
		return nil
	case job.FieldCreatedById:
		m.ResetCreatedById()
		return nil
	case job.FieldCategorySubId:
		m.ResetCategorySubId()
		return nil
	}
	return fmt.Errorf("unknown Job field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *JobMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *JobMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *JobMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *JobMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *JobMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *JobMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *JobMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Job unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *JobMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Job edge %s", name)
}

// MessageMutation represents an operation that mutates the Message nodes in the graph.
type MessageMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	payload       *string
	sent          *int
	addsent       *int
	resent        *int
	addresent     *int
	sentAt        *time.Time
	jobId         *int
	addjobId      *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Message, error)
	predicates    []predicate.Message
}

var _ ent.Mutation = (*MessageMutation)(nil)

// messageOption allows management of the mutation configuration using functional options.
type messageOption func(*MessageMutation)

// newMessageMutation creates new mutation for the Message entity.
func newMessageMutation(c config, op Op, opts ...messageOption) *MessageMutation {
	m := &MessageMutation{
		config:        c,
		op:            op,
		typ:           TypeMessage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMessageID sets the ID field of the mutation.
func withMessageID(id int64) messageOption {
	return func(m *MessageMutation) {
		var (
			err   error
			once  sync.Once
			value *Message
		)
		m.oldValue = func(ctx context.Context) (*Message, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Message.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMessage sets the old Message of the mutation.
func withMessage(node *Message) messageOption {
	return func(m *MessageMutation) {
		m.oldValue = func(context.Context) (*Message, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MessageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MessageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Message entities.
func (m *MessageMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MessageMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MessageMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Message.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPayload sets the "payload" field.
func (m *MessageMutation) SetPayload(s string) {
	m.payload = &s
}

// Payload returns the value of the "payload" field in the mutation.
func (m *MessageMutation) Payload() (r string, exists bool) {
	v := m.payload
	if v == nil {
		return
	}
	return *v, true
}

// OldPayload returns the old "payload" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldPayload(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPayload is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPayload requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayload: %w", err)
	}
	return oldValue.Payload, nil
}

// ResetPayload resets all changes to the "payload" field.
func (m *MessageMutation) ResetPayload() {
	m.payload = nil
}

// SetSent sets the "sent" field.
func (m *MessageMutation) SetSent(i int) {
	m.sent = &i
	m.addsent = nil
}

// Sent returns the value of the "sent" field in the mutation.
func (m *MessageMutation) Sent() (r int, exists bool) {
	v := m.sent
	if v == nil {
		return
	}
	return *v, true
}

// OldSent returns the old "sent" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldSent(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSent: %w", err)
	}
	return oldValue.Sent, nil
}

// AddSent adds i to the "sent" field.
func (m *MessageMutation) AddSent(i int) {
	if m.addsent != nil {
		*m.addsent += i
	} else {
		m.addsent = &i
	}
}

// AddedSent returns the value that was added to the "sent" field in this mutation.
func (m *MessageMutation) AddedSent() (r int, exists bool) {
	v := m.addsent
	if v == nil {
		return
	}
	return *v, true
}

// ResetSent resets all changes to the "sent" field.
func (m *MessageMutation) ResetSent() {
	m.sent = nil
	m.addsent = nil
}

// SetResent sets the "resent" field.
func (m *MessageMutation) SetResent(i int) {
	m.resent = &i
	m.addresent = nil
}

// Resent returns the value of the "resent" field in the mutation.
func (m *MessageMutation) Resent() (r int, exists bool) {
	v := m.resent
	if v == nil {
		return
	}
	return *v, true
}

// OldResent returns the old "resent" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldResent(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResent: %w", err)
	}
	return oldValue.Resent, nil
}

// AddResent adds i to the "resent" field.
func (m *MessageMutation) AddResent(i int) {
	if m.addresent != nil {
		*m.addresent += i
	} else {
		m.addresent = &i
	}
}

// AddedResent returns the value that was added to the "resent" field in this mutation.
func (m *MessageMutation) AddedResent() (r int, exists bool) {
	v := m.addresent
	if v == nil {
		return
	}
	return *v, true
}

// ResetResent resets all changes to the "resent" field.
func (m *MessageMutation) ResetResent() {
	m.resent = nil
	m.addresent = nil
}

// SetSentAt sets the "sentAt" field.
func (m *MessageMutation) SetSentAt(t time.Time) {
	m.sentAt = &t
}

// SentAt returns the value of the "sentAt" field in the mutation.
func (m *MessageMutation) SentAt() (r time.Time, exists bool) {
	v := m.sentAt
	if v == nil {
		return
	}
	return *v, true
}

// OldSentAt returns the old "sentAt" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldSentAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSentAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSentAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSentAt: %w", err)
	}
	return oldValue.SentAt, nil
}

// ResetSentAt resets all changes to the "sentAt" field.
func (m *MessageMutation) ResetSentAt() {
	m.sentAt = nil
}

// SetJobId sets the "jobId" field.
func (m *MessageMutation) SetJobId(i int) {
	m.jobId = &i
	m.addjobId = nil
}

// JobId returns the value of the "jobId" field in the mutation.
func (m *MessageMutation) JobId() (r int, exists bool) {
	v := m.jobId
	if v == nil {
		return
	}
	return *v, true
}

// OldJobId returns the old "jobId" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldJobId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJobId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJobId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJobId: %w", err)
	}
	return oldValue.JobId, nil
}

// AddJobId adds i to the "jobId" field.
func (m *MessageMutation) AddJobId(i int) {
	if m.addjobId != nil {
		*m.addjobId += i
	} else {
		m.addjobId = &i
	}
}

// AddedJobId returns the value that was added to the "jobId" field in this mutation.
func (m *MessageMutation) AddedJobId() (r int, exists bool) {
	v := m.addjobId
	if v == nil {
		return
	}
	return *v, true
}

// ResetJobId resets all changes to the "jobId" field.
func (m *MessageMutation) ResetJobId() {
	m.jobId = nil
	m.addjobId = nil
}

// Where appends a list predicates to the MessageMutation builder.
func (m *MessageMutation) Where(ps ...predicate.Message) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MessageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MessageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Message, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MessageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MessageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Message).
func (m *MessageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MessageMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.payload != nil {
		fields = append(fields, message.FieldPayload)
	}
	if m.sent != nil {
		fields = append(fields, message.FieldSent)
	}
	if m.resent != nil {
		fields = append(fields, message.FieldResent)
	}
	if m.sentAt != nil {
		fields = append(fields, message.FieldSentAt)
	}
	if m.jobId != nil {
		fields = append(fields, message.FieldJobId)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MessageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case message.FieldPayload:
		return m.Payload()
	case message.FieldSent:
		return m.Sent()
	case message.FieldResent:
		return m.Resent()
	case message.FieldSentAt:
		return m.SentAt()
	case message.FieldJobId:
		return m.JobId()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MessageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case message.FieldPayload:
		return m.OldPayload(ctx)
	case message.FieldSent:
		return m.OldSent(ctx)
	case message.FieldResent:
		return m.OldResent(ctx)
	case message.FieldSentAt:
		return m.OldSentAt(ctx)
	case message.FieldJobId:
		return m.OldJobId(ctx)
	}
	return nil, fmt.Errorf("unknown Message field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MessageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case message.FieldPayload:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayload(v)
		return nil
	case message.FieldSent:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSent(v)
		return nil
	case message.FieldResent:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResent(v)
		return nil
	case message.FieldSentAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSentAt(v)
		return nil
	case message.FieldJobId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJobId(v)
		return nil
	}
	return fmt.Errorf("unknown Message field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MessageMutation) AddedFields() []string {
	var fields []string
	if m.addsent != nil {
		fields = append(fields, message.FieldSent)
	}
	if m.addresent != nil {
		fields = append(fields, message.FieldResent)
	}
	if m.addjobId != nil {
		fields = append(fields, message.FieldJobId)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MessageMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case message.FieldSent:
		return m.AddedSent()
	case message.FieldResent:
		return m.AddedResent()
	case message.FieldJobId:
		return m.AddedJobId()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MessageMutation) AddField(name string, value ent.Value) error {
	switch name {
	case message.FieldSent:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSent(v)
		return nil
	case message.FieldResent:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddResent(v)
		return nil
	case message.FieldJobId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddJobId(v)
		return nil
	}
	return fmt.Errorf("unknown Message numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MessageMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MessageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MessageMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Message nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MessageMutation) ResetField(name string) error {
	switch name {
	case message.FieldPayload:
		m.ResetPayload()
		return nil
	case message.FieldSent:
		m.ResetSent()
		return nil
	case message.FieldResent:
		m.ResetResent()
		return nil
	case message.FieldSentAt:
		m.ResetSentAt()
		return nil
	case message.FieldJobId:
		m.ResetJobId()
		return nil
	}
	return fmt.Errorf("unknown Message field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MessageMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MessageMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MessageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MessageMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MessageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MessageMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MessageMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Message unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MessageMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Message edge %s", name)
}

// MessageMailMutation represents an operation that mutates the MessageMail nodes in the graph.
type MessageMailMutation struct {
	config
	op             Op
	typ            string
	id             *int
	seq            *int64
	addseq         *int64
	mailSubject    *string
	mailContents   *string
	mailGb         *int
	addmailGb      *int
	mailRecvGroup  *string
	sent           *int
	addsent        *int
	sentAt         *time.Time
	createdById    *int
	addcreatedById *int
	createdAt      *time.Time
	updatedById    *int
	addupdatedById *int
	updatedAt      *time.Time
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*MessageMail, error)
	predicates     []predicate.MessageMail
}

var _ ent.Mutation = (*MessageMailMutation)(nil)

// messagemailOption allows management of the mutation configuration using functional options.
type messagemailOption func(*MessageMailMutation)

// newMessageMailMutation creates new mutation for the MessageMail entity.
func newMessageMailMutation(c config, op Op, opts ...messagemailOption) *MessageMailMutation {
	m := &MessageMailMutation{
		config:        c,
		op:            op,
		typ:           TypeMessageMail,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMessageMailID sets the ID field of the mutation.
func withMessageMailID(id int) messagemailOption {
	return func(m *MessageMailMutation) {
		var (
			err   error
			once  sync.Once
			value *MessageMail
		)
		m.oldValue = func(ctx context.Context) (*MessageMail, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MessageMail.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMessageMail sets the old MessageMail of the mutation.
func withMessageMail(node *MessageMail) messagemailOption {
	return func(m *MessageMailMutation) {
		m.oldValue = func(context.Context) (*MessageMail, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MessageMailMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MessageMailMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MessageMailMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MessageMailMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MessageMail.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSeq sets the "seq" field.
func (m *MessageMailMutation) SetSeq(i int64) {
	m.seq = &i
	m.addseq = nil
}

// Seq returns the value of the "seq" field in the mutation.
func (m *MessageMailMutation) Seq() (r int64, exists bool) {
	v := m.seq
	if v == nil {
		return
	}
	return *v, true
}

// OldSeq returns the old "seq" field's value of the MessageMail entity.
// If the MessageMail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMailMutation) OldSeq(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeq is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeq requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeq: %w", err)
	}
	return oldValue.Seq, nil
}

// AddSeq adds i to the "seq" field.
func (m *MessageMailMutation) AddSeq(i int64) {
	if m.addseq != nil {
		*m.addseq += i
	} else {
		m.addseq = &i
	}
}

// AddedSeq returns the value that was added to the "seq" field in this mutation.
func (m *MessageMailMutation) AddedSeq() (r int64, exists bool) {
	v := m.addseq
	if v == nil {
		return
	}
	return *v, true
}

// ResetSeq resets all changes to the "seq" field.
func (m *MessageMailMutation) ResetSeq() {
	m.seq = nil
	m.addseq = nil
}

// SetMailSubject sets the "mailSubject" field.
func (m *MessageMailMutation) SetMailSubject(s string) {
	m.mailSubject = &s
}

// MailSubject returns the value of the "mailSubject" field in the mutation.
func (m *MessageMailMutation) MailSubject() (r string, exists bool) {
	v := m.mailSubject
	if v == nil {
		return
	}
	return *v, true
}

// OldMailSubject returns the old "mailSubject" field's value of the MessageMail entity.
// If the MessageMail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMailMutation) OldMailSubject(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMailSubject is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMailSubject requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMailSubject: %w", err)
	}
	return oldValue.MailSubject, nil
}

// ResetMailSubject resets all changes to the "mailSubject" field.
func (m *MessageMailMutation) ResetMailSubject() {
	m.mailSubject = nil
}

// SetMailContents sets the "mailContents" field.
func (m *MessageMailMutation) SetMailContents(s string) {
	m.mailContents = &s
}

// MailContents returns the value of the "mailContents" field in the mutation.
func (m *MessageMailMutation) MailContents() (r string, exists bool) {
	v := m.mailContents
	if v == nil {
		return
	}
	return *v, true
}

// OldMailContents returns the old "mailContents" field's value of the MessageMail entity.
// If the MessageMail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMailMutation) OldMailContents(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMailContents is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMailContents requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMailContents: %w", err)
	}
	return oldValue.MailContents, nil
}

// ResetMailContents resets all changes to the "mailContents" field.
func (m *MessageMailMutation) ResetMailContents() {
	m.mailContents = nil
}

// SetMailGb sets the "mailGb" field.
func (m *MessageMailMutation) SetMailGb(i int) {
	m.mailGb = &i
	m.addmailGb = nil
}

// MailGb returns the value of the "mailGb" field in the mutation.
func (m *MessageMailMutation) MailGb() (r int, exists bool) {
	v := m.mailGb
	if v == nil {
		return
	}
	return *v, true
}

// OldMailGb returns the old "mailGb" field's value of the MessageMail entity.
// If the MessageMail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMailMutation) OldMailGb(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMailGb is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMailGb requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMailGb: %w", err)
	}
	return oldValue.MailGb, nil
}

// AddMailGb adds i to the "mailGb" field.
func (m *MessageMailMutation) AddMailGb(i int) {
	if m.addmailGb != nil {
		*m.addmailGb += i
	} else {
		m.addmailGb = &i
	}
}

// AddedMailGb returns the value that was added to the "mailGb" field in this mutation.
func (m *MessageMailMutation) AddedMailGb() (r int, exists bool) {
	v := m.addmailGb
	if v == nil {
		return
	}
	return *v, true
}

// ResetMailGb resets all changes to the "mailGb" field.
func (m *MessageMailMutation) ResetMailGb() {
	m.mailGb = nil
	m.addmailGb = nil
}

// SetMailRecvGroup sets the "mailRecvGroup" field.
func (m *MessageMailMutation) SetMailRecvGroup(s string) {
	m.mailRecvGroup = &s
}

// MailRecvGroup returns the value of the "mailRecvGroup" field in the mutation.
func (m *MessageMailMutation) MailRecvGroup() (r string, exists bool) {
	v := m.mailRecvGroup
	if v == nil {
		return
	}
	return *v, true
}

// OldMailRecvGroup returns the old "mailRecvGroup" field's value of the MessageMail entity.
// If the MessageMail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMailMutation) OldMailRecvGroup(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMailRecvGroup is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMailRecvGroup requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMailRecvGroup: %w", err)
	}
	return oldValue.MailRecvGroup, nil
}

// ResetMailRecvGroup resets all changes to the "mailRecvGroup" field.
func (m *MessageMailMutation) ResetMailRecvGroup() {
	m.mailRecvGroup = nil
}

// SetSent sets the "sent" field.
func (m *MessageMailMutation) SetSent(i int) {
	m.sent = &i
	m.addsent = nil
}

// Sent returns the value of the "sent" field in the mutation.
func (m *MessageMailMutation) Sent() (r int, exists bool) {
	v := m.sent
	if v == nil {
		return
	}
	return *v, true
}

// OldSent returns the old "sent" field's value of the MessageMail entity.
// If the MessageMail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMailMutation) OldSent(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSent: %w", err)
	}
	return oldValue.Sent, nil
}

// AddSent adds i to the "sent" field.
func (m *MessageMailMutation) AddSent(i int) {
	if m.addsent != nil {
		*m.addsent += i
	} else {
		m.addsent = &i
	}
}

// AddedSent returns the value that was added to the "sent" field in this mutation.
func (m *MessageMailMutation) AddedSent() (r int, exists bool) {
	v := m.addsent
	if v == nil {
		return
	}
	return *v, true
}

// ResetSent resets all changes to the "sent" field.
func (m *MessageMailMutation) ResetSent() {
	m.sent = nil
	m.addsent = nil
}

// SetSentAt sets the "sentAt" field.
func (m *MessageMailMutation) SetSentAt(t time.Time) {
	m.sentAt = &t
}

// SentAt returns the value of the "sentAt" field in the mutation.
func (m *MessageMailMutation) SentAt() (r time.Time, exists bool) {
	v := m.sentAt
	if v == nil {
		return
	}
	return *v, true
}

// OldSentAt returns the old "sentAt" field's value of the MessageMail entity.
// If the MessageMail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMailMutation) OldSentAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSentAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSentAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSentAt: %w", err)
	}
	return oldValue.SentAt, nil
}

// ResetSentAt resets all changes to the "sentAt" field.
func (m *MessageMailMutation) ResetSentAt() {
	m.sentAt = nil
}

// SetCreatedById sets the "createdById" field.
func (m *MessageMailMutation) SetCreatedById(i int) {
	m.createdById = &i
	m.addcreatedById = nil
}

// CreatedById returns the value of the "createdById" field in the mutation.
func (m *MessageMailMutation) CreatedById() (r int, exists bool) {
	v := m.createdById
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedById returns the old "createdById" field's value of the MessageMail entity.
// If the MessageMail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMailMutation) OldCreatedById(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedById is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedById requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedById: %w", err)
	}
	return oldValue.CreatedById, nil
}

// AddCreatedById adds i to the "createdById" field.
func (m *MessageMailMutation) AddCreatedById(i int) {
	if m.addcreatedById != nil {
		*m.addcreatedById += i
	} else {
		m.addcreatedById = &i
	}
}

// AddedCreatedById returns the value that was added to the "createdById" field in this mutation.
func (m *MessageMailMutation) AddedCreatedById() (r int, exists bool) {
	v := m.addcreatedById
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedById resets all changes to the "createdById" field.
func (m *MessageMailMutation) ResetCreatedById() {
	m.createdById = nil
	m.addcreatedById = nil
}

// SetCreatedAt sets the "createdAt" field.
func (m *MessageMailMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *MessageMailMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the MessageMail entity.
// If the MessageMail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMailMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *MessageMailMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedById sets the "updatedById" field.
func (m *MessageMailMutation) SetUpdatedById(i int) {
	m.updatedById = &i
	m.addupdatedById = nil
}

// UpdatedById returns the value of the "updatedById" field in the mutation.
func (m *MessageMailMutation) UpdatedById() (r int, exists bool) {
	v := m.updatedById
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedById returns the old "updatedById" field's value of the MessageMail entity.
// If the MessageMail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMailMutation) OldUpdatedById(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedById is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedById requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedById: %w", err)
	}
	return oldValue.UpdatedById, nil
}

// AddUpdatedById adds i to the "updatedById" field.
func (m *MessageMailMutation) AddUpdatedById(i int) {
	if m.addupdatedById != nil {
		*m.addupdatedById += i
	} else {
		m.addupdatedById = &i
	}
}

// AddedUpdatedById returns the value that was added to the "updatedById" field in this mutation.
func (m *MessageMailMutation) AddedUpdatedById() (r int, exists bool) {
	v := m.addupdatedById
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedById resets all changes to the "updatedById" field.
func (m *MessageMailMutation) ResetUpdatedById() {
	m.updatedById = nil
	m.addupdatedById = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *MessageMailMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *MessageMailMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the MessageMail entity.
// If the MessageMail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMailMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *MessageMailMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// Where appends a list predicates to the MessageMailMutation builder.
func (m *MessageMailMutation) Where(ps ...predicate.MessageMail) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MessageMailMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MessageMailMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MessageMail, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MessageMailMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MessageMailMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MessageMail).
func (m *MessageMailMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MessageMailMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.seq != nil {
		fields = append(fields, messagemail.FieldSeq)
	}
	if m.mailSubject != nil {
		fields = append(fields, messagemail.FieldMailSubject)
	}
	if m.mailContents != nil {
		fields = append(fields, messagemail.FieldMailContents)
	}
	if m.mailGb != nil {
		fields = append(fields, messagemail.FieldMailGb)
	}
	if m.mailRecvGroup != nil {
		fields = append(fields, messagemail.FieldMailRecvGroup)
	}
	if m.sent != nil {
		fields = append(fields, messagemail.FieldSent)
	}
	if m.sentAt != nil {
		fields = append(fields, messagemail.FieldSentAt)
	}
	if m.createdById != nil {
		fields = append(fields, messagemail.FieldCreatedById)
	}
	if m.createdAt != nil {
		fields = append(fields, messagemail.FieldCreatedAt)
	}
	if m.updatedById != nil {
		fields = append(fields, messagemail.FieldUpdatedById)
	}
	if m.updatedAt != nil {
		fields = append(fields, messagemail.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MessageMailMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case messagemail.FieldSeq:
		return m.Seq()
	case messagemail.FieldMailSubject:
		return m.MailSubject()
	case messagemail.FieldMailContents:
		return m.MailContents()
	case messagemail.FieldMailGb:
		return m.MailGb()
	case messagemail.FieldMailRecvGroup:
		return m.MailRecvGroup()
	case messagemail.FieldSent:
		return m.Sent()
	case messagemail.FieldSentAt:
		return m.SentAt()
	case messagemail.FieldCreatedById:
		return m.CreatedById()
	case messagemail.FieldCreatedAt:
		return m.CreatedAt()
	case messagemail.FieldUpdatedById:
		return m.UpdatedById()
	case messagemail.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MessageMailMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case messagemail.FieldSeq:
		return m.OldSeq(ctx)
	case messagemail.FieldMailSubject:
		return m.OldMailSubject(ctx)
	case messagemail.FieldMailContents:
		return m.OldMailContents(ctx)
	case messagemail.FieldMailGb:
		return m.OldMailGb(ctx)
	case messagemail.FieldMailRecvGroup:
		return m.OldMailRecvGroup(ctx)
	case messagemail.FieldSent:
		return m.OldSent(ctx)
	case messagemail.FieldSentAt:
		return m.OldSentAt(ctx)
	case messagemail.FieldCreatedById:
		return m.OldCreatedById(ctx)
	case messagemail.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case messagemail.FieldUpdatedById:
		return m.OldUpdatedById(ctx)
	case messagemail.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown MessageMail field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MessageMailMutation) SetField(name string, value ent.Value) error {
	switch name {
	case messagemail.FieldSeq:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeq(v)
		return nil
	case messagemail.FieldMailSubject:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMailSubject(v)
		return nil
	case messagemail.FieldMailContents:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMailContents(v)
		return nil
	case messagemail.FieldMailGb:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMailGb(v)
		return nil
	case messagemail.FieldMailRecvGroup:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMailRecvGroup(v)
		return nil
	case messagemail.FieldSent:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSent(v)
		return nil
	case messagemail.FieldSentAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSentAt(v)
		return nil
	case messagemail.FieldCreatedById:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedById(v)
		return nil
	case messagemail.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case messagemail.FieldUpdatedById:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedById(v)
		return nil
	case messagemail.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown MessageMail field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MessageMailMutation) AddedFields() []string {
	var fields []string
	if m.addseq != nil {
		fields = append(fields, messagemail.FieldSeq)
	}
	if m.addmailGb != nil {
		fields = append(fields, messagemail.FieldMailGb)
	}
	if m.addsent != nil {
		fields = append(fields, messagemail.FieldSent)
	}
	if m.addcreatedById != nil {
		fields = append(fields, messagemail.FieldCreatedById)
	}
	if m.addupdatedById != nil {
		fields = append(fields, messagemail.FieldUpdatedById)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MessageMailMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case messagemail.FieldSeq:
		return m.AddedSeq()
	case messagemail.FieldMailGb:
		return m.AddedMailGb()
	case messagemail.FieldSent:
		return m.AddedSent()
	case messagemail.FieldCreatedById:
		return m.AddedCreatedById()
	case messagemail.FieldUpdatedById:
		return m.AddedUpdatedById()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MessageMailMutation) AddField(name string, value ent.Value) error {
	switch name {
	case messagemail.FieldSeq:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSeq(v)
		return nil
	case messagemail.FieldMailGb:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMailGb(v)
		return nil
	case messagemail.FieldSent:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSent(v)
		return nil
	case messagemail.FieldCreatedById:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedById(v)
		return nil
	case messagemail.FieldUpdatedById:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedById(v)
		return nil
	}
	return fmt.Errorf("unknown MessageMail numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MessageMailMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MessageMailMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MessageMailMutation) ClearField(name string) error {
	return fmt.Errorf("unknown MessageMail nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MessageMailMutation) ResetField(name string) error {
	switch name {
	case messagemail.FieldSeq:
		m.ResetSeq()
		return nil
	case messagemail.FieldMailSubject:
		m.ResetMailSubject()
		return nil
	case messagemail.FieldMailContents:
		m.ResetMailContents()
		return nil
	case messagemail.FieldMailGb:
		m.ResetMailGb()
		return nil
	case messagemail.FieldMailRecvGroup:
		m.ResetMailRecvGroup()
		return nil
	case messagemail.FieldSent:
		m.ResetSent()
		return nil
	case messagemail.FieldSentAt:
		m.ResetSentAt()
		return nil
	case messagemail.FieldCreatedById:
		m.ResetCreatedById()
		return nil
	case messagemail.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case messagemail.FieldUpdatedById:
		m.ResetUpdatedById()
		return nil
	case messagemail.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown MessageMail field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MessageMailMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MessageMailMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MessageMailMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MessageMailMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MessageMailMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MessageMailMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MessageMailMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown MessageMail unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MessageMailMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown MessageMail edge %s", name)
}

// ScriptMutation represents an operation that mutates the Script nodes in the graph.
type ScriptMutation struct {
	config
	op                Op
	typ               string
	id                *int64
	program           *string
	updatedAt         *time.Time
	createdAt         *time.Time
	jobId             *int
	addjobId          *int
	hostname          *string
	command           *string
	comment           *string
	usable            *int
	addusable         *int
	repeatInterval    *int
	addrepeatInterval *int
	updatedById       *int
	addupdatedById    *int
	createdById       *int
	addcreatedById    *int
	regionId          *int
	addregionId       *int
	managerId         *int
	addmanagerId      *int
	managerGroupId    *int
	addmanagerGroupId *int
	startTime         *time.Time
	endTime           *time.Time
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*Script, error)
	predicates        []predicate.Script
}

var _ ent.Mutation = (*ScriptMutation)(nil)

// scriptOption allows management of the mutation configuration using functional options.
type scriptOption func(*ScriptMutation)

// newScriptMutation creates new mutation for the Script entity.
func newScriptMutation(c config, op Op, opts ...scriptOption) *ScriptMutation {
	m := &ScriptMutation{
		config:        c,
		op:            op,
		typ:           TypeScript,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withScriptID sets the ID field of the mutation.
func withScriptID(id int64) scriptOption {
	return func(m *ScriptMutation) {
		var (
			err   error
			once  sync.Once
			value *Script
		)
		m.oldValue = func(ctx context.Context) (*Script, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Script.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withScript sets the old Script of the mutation.
func withScript(node *Script) scriptOption {
	return func(m *ScriptMutation) {
		m.oldValue = func(context.Context) (*Script, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ScriptMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ScriptMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Script entities.
func (m *ScriptMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ScriptMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ScriptMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Script.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetProgram sets the "program" field.
func (m *ScriptMutation) SetProgram(s string) {
	m.program = &s
}

// Program returns the value of the "program" field in the mutation.
func (m *ScriptMutation) Program() (r string, exists bool) {
	v := m.program
	if v == nil {
		return
	}
	return *v, true
}

// OldProgram returns the old "program" field's value of the Script entity.
// If the Script object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScriptMutation) OldProgram(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProgram is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProgram requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProgram: %w", err)
	}
	return oldValue.Program, nil
}

// ResetProgram resets all changes to the "program" field.
func (m *ScriptMutation) ResetProgram() {
	m.program = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *ScriptMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *ScriptMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the Script entity.
// If the Script object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScriptMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *ScriptMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetCreatedAt sets the "createdAt" field.
func (m *ScriptMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *ScriptMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the Script entity.
// If the Script object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScriptMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *ScriptMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetJobId sets the "jobId" field.
func (m *ScriptMutation) SetJobId(i int) {
	m.jobId = &i
	m.addjobId = nil
}

// JobId returns the value of the "jobId" field in the mutation.
func (m *ScriptMutation) JobId() (r int, exists bool) {
	v := m.jobId
	if v == nil {
		return
	}
	return *v, true
}

// OldJobId returns the old "jobId" field's value of the Script entity.
// If the Script object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScriptMutation) OldJobId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJobId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJobId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJobId: %w", err)
	}
	return oldValue.JobId, nil
}

// AddJobId adds i to the "jobId" field.
func (m *ScriptMutation) AddJobId(i int) {
	if m.addjobId != nil {
		*m.addjobId += i
	} else {
		m.addjobId = &i
	}
}

// AddedJobId returns the value that was added to the "jobId" field in this mutation.
func (m *ScriptMutation) AddedJobId() (r int, exists bool) {
	v := m.addjobId
	if v == nil {
		return
	}
	return *v, true
}

// ResetJobId resets all changes to the "jobId" field.
func (m *ScriptMutation) ResetJobId() {
	m.jobId = nil
	m.addjobId = nil
}

// SetHostname sets the "hostname" field.
func (m *ScriptMutation) SetHostname(s string) {
	m.hostname = &s
}

// Hostname returns the value of the "hostname" field in the mutation.
func (m *ScriptMutation) Hostname() (r string, exists bool) {
	v := m.hostname
	if v == nil {
		return
	}
	return *v, true
}

// OldHostname returns the old "hostname" field's value of the Script entity.
// If the Script object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScriptMutation) OldHostname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHostname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHostname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHostname: %w", err)
	}
	return oldValue.Hostname, nil
}

// ResetHostname resets all changes to the "hostname" field.
func (m *ScriptMutation) ResetHostname() {
	m.hostname = nil
}

// SetCommand sets the "command" field.
func (m *ScriptMutation) SetCommand(s string) {
	m.command = &s
}

// Command returns the value of the "command" field in the mutation.
func (m *ScriptMutation) Command() (r string, exists bool) {
	v := m.command
	if v == nil {
		return
	}
	return *v, true
}

// OldCommand returns the old "command" field's value of the Script entity.
// If the Script object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScriptMutation) OldCommand(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommand is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommand requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommand: %w", err)
	}
	return oldValue.Command, nil
}

// ResetCommand resets all changes to the "command" field.
func (m *ScriptMutation) ResetCommand() {
	m.command = nil
}

// SetComment sets the "comment" field.
func (m *ScriptMutation) SetComment(s string) {
	m.comment = &s
}

// Comment returns the value of the "comment" field in the mutation.
func (m *ScriptMutation) Comment() (r string, exists bool) {
	v := m.comment
	if v == nil {
		return
	}
	return *v, true
}

// OldComment returns the old "comment" field's value of the Script entity.
// If the Script object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScriptMutation) OldComment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComment: %w", err)
	}
	return oldValue.Comment, nil
}

// ResetComment resets all changes to the "comment" field.
func (m *ScriptMutation) ResetComment() {
	m.comment = nil
}

// SetUsable sets the "usable" field.
func (m *ScriptMutation) SetUsable(i int) {
	m.usable = &i
	m.addusable = nil
}

// Usable returns the value of the "usable" field in the mutation.
func (m *ScriptMutation) Usable() (r int, exists bool) {
	v := m.usable
	if v == nil {
		return
	}
	return *v, true
}

// OldUsable returns the old "usable" field's value of the Script entity.
// If the Script object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScriptMutation) OldUsable(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsable: %w", err)
	}
	return oldValue.Usable, nil
}

// AddUsable adds i to the "usable" field.
func (m *ScriptMutation) AddUsable(i int) {
	if m.addusable != nil {
		*m.addusable += i
	} else {
		m.addusable = &i
	}
}

// AddedUsable returns the value that was added to the "usable" field in this mutation.
func (m *ScriptMutation) AddedUsable() (r int, exists bool) {
	v := m.addusable
	if v == nil {
		return
	}
	return *v, true
}

// ResetUsable resets all changes to the "usable" field.
func (m *ScriptMutation) ResetUsable() {
	m.usable = nil
	m.addusable = nil
}

// SetRepeatInterval sets the "repeatInterval" field.
func (m *ScriptMutation) SetRepeatInterval(i int) {
	m.repeatInterval = &i
	m.addrepeatInterval = nil
}

// RepeatInterval returns the value of the "repeatInterval" field in the mutation.
func (m *ScriptMutation) RepeatInterval() (r int, exists bool) {
	v := m.repeatInterval
	if v == nil {
		return
	}
	return *v, true
}

// OldRepeatInterval returns the old "repeatInterval" field's value of the Script entity.
// If the Script object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScriptMutation) OldRepeatInterval(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRepeatInterval is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRepeatInterval requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRepeatInterval: %w", err)
	}
	return oldValue.RepeatInterval, nil
}

// AddRepeatInterval adds i to the "repeatInterval" field.
func (m *ScriptMutation) AddRepeatInterval(i int) {
	if m.addrepeatInterval != nil {
		*m.addrepeatInterval += i
	} else {
		m.addrepeatInterval = &i
	}
}

// AddedRepeatInterval returns the value that was added to the "repeatInterval" field in this mutation.
func (m *ScriptMutation) AddedRepeatInterval() (r int, exists bool) {
	v := m.addrepeatInterval
	if v == nil {
		return
	}
	return *v, true
}

// ResetRepeatInterval resets all changes to the "repeatInterval" field.
func (m *ScriptMutation) ResetRepeatInterval() {
	m.repeatInterval = nil
	m.addrepeatInterval = nil
}

// SetUpdatedById sets the "updatedById" field.
func (m *ScriptMutation) SetUpdatedById(i int) {
	m.updatedById = &i
	m.addupdatedById = nil
}

// UpdatedById returns the value of the "updatedById" field in the mutation.
func (m *ScriptMutation) UpdatedById() (r int, exists bool) {
	v := m.updatedById
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedById returns the old "updatedById" field's value of the Script entity.
// If the Script object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScriptMutation) OldUpdatedById(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedById is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedById requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedById: %w", err)
	}
	return oldValue.UpdatedById, nil
}

// AddUpdatedById adds i to the "updatedById" field.
func (m *ScriptMutation) AddUpdatedById(i int) {
	if m.addupdatedById != nil {
		*m.addupdatedById += i
	} else {
		m.addupdatedById = &i
	}
}

// AddedUpdatedById returns the value that was added to the "updatedById" field in this mutation.
func (m *ScriptMutation) AddedUpdatedById() (r int, exists bool) {
	v := m.addupdatedById
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedById resets all changes to the "updatedById" field.
func (m *ScriptMutation) ResetUpdatedById() {
	m.updatedById = nil
	m.addupdatedById = nil
}

// SetCreatedById sets the "createdById" field.
func (m *ScriptMutation) SetCreatedById(i int) {
	m.createdById = &i
	m.addcreatedById = nil
}

// CreatedById returns the value of the "createdById" field in the mutation.
func (m *ScriptMutation) CreatedById() (r int, exists bool) {
	v := m.createdById
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedById returns the old "createdById" field's value of the Script entity.
// If the Script object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScriptMutation) OldCreatedById(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedById is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedById requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedById: %w", err)
	}
	return oldValue.CreatedById, nil
}

// AddCreatedById adds i to the "createdById" field.
func (m *ScriptMutation) AddCreatedById(i int) {
	if m.addcreatedById != nil {
		*m.addcreatedById += i
	} else {
		m.addcreatedById = &i
	}
}

// AddedCreatedById returns the value that was added to the "createdById" field in this mutation.
func (m *ScriptMutation) AddedCreatedById() (r int, exists bool) {
	v := m.addcreatedById
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedById resets all changes to the "createdById" field.
func (m *ScriptMutation) ResetCreatedById() {
	m.createdById = nil
	m.addcreatedById = nil
}

// SetRegionId sets the "regionId" field.
func (m *ScriptMutation) SetRegionId(i int) {
	m.regionId = &i
	m.addregionId = nil
}

// RegionId returns the value of the "regionId" field in the mutation.
func (m *ScriptMutation) RegionId() (r int, exists bool) {
	v := m.regionId
	if v == nil {
		return
	}
	return *v, true
}

// OldRegionId returns the old "regionId" field's value of the Script entity.
// If the Script object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScriptMutation) OldRegionId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegionId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegionId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegionId: %w", err)
	}
	return oldValue.RegionId, nil
}

// AddRegionId adds i to the "regionId" field.
func (m *ScriptMutation) AddRegionId(i int) {
	if m.addregionId != nil {
		*m.addregionId += i
	} else {
		m.addregionId = &i
	}
}

// AddedRegionId returns the value that was added to the "regionId" field in this mutation.
func (m *ScriptMutation) AddedRegionId() (r int, exists bool) {
	v := m.addregionId
	if v == nil {
		return
	}
	return *v, true
}

// ResetRegionId resets all changes to the "regionId" field.
func (m *ScriptMutation) ResetRegionId() {
	m.regionId = nil
	m.addregionId = nil
}

// SetManagerId sets the "managerId" field.
func (m *ScriptMutation) SetManagerId(i int) {
	m.managerId = &i
	m.addmanagerId = nil
}

// ManagerId returns the value of the "managerId" field in the mutation.
func (m *ScriptMutation) ManagerId() (r int, exists bool) {
	v := m.managerId
	if v == nil {
		return
	}
	return *v, true
}

// OldManagerId returns the old "managerId" field's value of the Script entity.
// If the Script object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScriptMutation) OldManagerId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldManagerId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldManagerId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldManagerId: %w", err)
	}
	return oldValue.ManagerId, nil
}

// AddManagerId adds i to the "managerId" field.
func (m *ScriptMutation) AddManagerId(i int) {
	if m.addmanagerId != nil {
		*m.addmanagerId += i
	} else {
		m.addmanagerId = &i
	}
}

// AddedManagerId returns the value that was added to the "managerId" field in this mutation.
func (m *ScriptMutation) AddedManagerId() (r int, exists bool) {
	v := m.addmanagerId
	if v == nil {
		return
	}
	return *v, true
}

// ResetManagerId resets all changes to the "managerId" field.
func (m *ScriptMutation) ResetManagerId() {
	m.managerId = nil
	m.addmanagerId = nil
}

// SetManagerGroupId sets the "managerGroupId" field.
func (m *ScriptMutation) SetManagerGroupId(i int) {
	m.managerGroupId = &i
	m.addmanagerGroupId = nil
}

// ManagerGroupId returns the value of the "managerGroupId" field in the mutation.
func (m *ScriptMutation) ManagerGroupId() (r int, exists bool) {
	v := m.managerGroupId
	if v == nil {
		return
	}
	return *v, true
}

// OldManagerGroupId returns the old "managerGroupId" field's value of the Script entity.
// If the Script object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScriptMutation) OldManagerGroupId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldManagerGroupId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldManagerGroupId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldManagerGroupId: %w", err)
	}
	return oldValue.ManagerGroupId, nil
}

// AddManagerGroupId adds i to the "managerGroupId" field.
func (m *ScriptMutation) AddManagerGroupId(i int) {
	if m.addmanagerGroupId != nil {
		*m.addmanagerGroupId += i
	} else {
		m.addmanagerGroupId = &i
	}
}

// AddedManagerGroupId returns the value that was added to the "managerGroupId" field in this mutation.
func (m *ScriptMutation) AddedManagerGroupId() (r int, exists bool) {
	v := m.addmanagerGroupId
	if v == nil {
		return
	}
	return *v, true
}

// ResetManagerGroupId resets all changes to the "managerGroupId" field.
func (m *ScriptMutation) ResetManagerGroupId() {
	m.managerGroupId = nil
	m.addmanagerGroupId = nil
}

// SetStartTime sets the "startTime" field.
func (m *ScriptMutation) SetStartTime(t time.Time) {
	m.startTime = &t
}

// StartTime returns the value of the "startTime" field in the mutation.
func (m *ScriptMutation) StartTime() (r time.Time, exists bool) {
	v := m.startTime
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTime returns the old "startTime" field's value of the Script entity.
// If the Script object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScriptMutation) OldStartTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTime: %w", err)
	}
	return oldValue.StartTime, nil
}

// ResetStartTime resets all changes to the "startTime" field.
func (m *ScriptMutation) ResetStartTime() {
	m.startTime = nil
}

// SetEndTime sets the "endTime" field.
func (m *ScriptMutation) SetEndTime(t time.Time) {
	m.endTime = &t
}

// EndTime returns the value of the "endTime" field in the mutation.
func (m *ScriptMutation) EndTime() (r time.Time, exists bool) {
	v := m.endTime
	if v == nil {
		return
	}
	return *v, true
}

// OldEndTime returns the old "endTime" field's value of the Script entity.
// If the Script object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScriptMutation) OldEndTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndTime: %w", err)
	}
	return oldValue.EndTime, nil
}

// ResetEndTime resets all changes to the "endTime" field.
func (m *ScriptMutation) ResetEndTime() {
	m.endTime = nil
}

// Where appends a list predicates to the ScriptMutation builder.
func (m *ScriptMutation) Where(ps ...predicate.Script) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ScriptMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ScriptMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Script, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ScriptMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ScriptMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Script).
func (m *ScriptMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ScriptMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.program != nil {
		fields = append(fields, script.FieldProgram)
	}
	if m.updatedAt != nil {
		fields = append(fields, script.FieldUpdatedAt)
	}
	if m.createdAt != nil {
		fields = append(fields, script.FieldCreatedAt)
	}
	if m.jobId != nil {
		fields = append(fields, script.FieldJobId)
	}
	if m.hostname != nil {
		fields = append(fields, script.FieldHostname)
	}
	if m.command != nil {
		fields = append(fields, script.FieldCommand)
	}
	if m.comment != nil {
		fields = append(fields, script.FieldComment)
	}
	if m.usable != nil {
		fields = append(fields, script.FieldUsable)
	}
	if m.repeatInterval != nil {
		fields = append(fields, script.FieldRepeatInterval)
	}
	if m.updatedById != nil {
		fields = append(fields, script.FieldUpdatedById)
	}
	if m.createdById != nil {
		fields = append(fields, script.FieldCreatedById)
	}
	if m.regionId != nil {
		fields = append(fields, script.FieldRegionId)
	}
	if m.managerId != nil {
		fields = append(fields, script.FieldManagerId)
	}
	if m.managerGroupId != nil {
		fields = append(fields, script.FieldManagerGroupId)
	}
	if m.startTime != nil {
		fields = append(fields, script.FieldStartTime)
	}
	if m.endTime != nil {
		fields = append(fields, script.FieldEndTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ScriptMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case script.FieldProgram:
		return m.Program()
	case script.FieldUpdatedAt:
		return m.UpdatedAt()
	case script.FieldCreatedAt:
		return m.CreatedAt()
	case script.FieldJobId:
		return m.JobId()
	case script.FieldHostname:
		return m.Hostname()
	case script.FieldCommand:
		return m.Command()
	case script.FieldComment:
		return m.Comment()
	case script.FieldUsable:
		return m.Usable()
	case script.FieldRepeatInterval:
		return m.RepeatInterval()
	case script.FieldUpdatedById:
		return m.UpdatedById()
	case script.FieldCreatedById:
		return m.CreatedById()
	case script.FieldRegionId:
		return m.RegionId()
	case script.FieldManagerId:
		return m.ManagerId()
	case script.FieldManagerGroupId:
		return m.ManagerGroupId()
	case script.FieldStartTime:
		return m.StartTime()
	case script.FieldEndTime:
		return m.EndTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ScriptMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case script.FieldProgram:
		return m.OldProgram(ctx)
	case script.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case script.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case script.FieldJobId:
		return m.OldJobId(ctx)
	case script.FieldHostname:
		return m.OldHostname(ctx)
	case script.FieldCommand:
		return m.OldCommand(ctx)
	case script.FieldComment:
		return m.OldComment(ctx)
	case script.FieldUsable:
		return m.OldUsable(ctx)
	case script.FieldRepeatInterval:
		return m.OldRepeatInterval(ctx)
	case script.FieldUpdatedById:
		return m.OldUpdatedById(ctx)
	case script.FieldCreatedById:
		return m.OldCreatedById(ctx)
	case script.FieldRegionId:
		return m.OldRegionId(ctx)
	case script.FieldManagerId:
		return m.OldManagerId(ctx)
	case script.FieldManagerGroupId:
		return m.OldManagerGroupId(ctx)
	case script.FieldStartTime:
		return m.OldStartTime(ctx)
	case script.FieldEndTime:
		return m.OldEndTime(ctx)
	}
	return nil, fmt.Errorf("unknown Script field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScriptMutation) SetField(name string, value ent.Value) error {
	switch name {
	case script.FieldProgram:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProgram(v)
		return nil
	case script.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case script.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case script.FieldJobId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJobId(v)
		return nil
	case script.FieldHostname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHostname(v)
		return nil
	case script.FieldCommand:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommand(v)
		return nil
	case script.FieldComment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComment(v)
		return nil
	case script.FieldUsable:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsable(v)
		return nil
	case script.FieldRepeatInterval:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRepeatInterval(v)
		return nil
	case script.FieldUpdatedById:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedById(v)
		return nil
	case script.FieldCreatedById:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedById(v)
		return nil
	case script.FieldRegionId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegionId(v)
		return nil
	case script.FieldManagerId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetManagerId(v)
		return nil
	case script.FieldManagerGroupId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetManagerGroupId(v)
		return nil
	case script.FieldStartTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTime(v)
		return nil
	case script.FieldEndTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndTime(v)
		return nil
	}
	return fmt.Errorf("unknown Script field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ScriptMutation) AddedFields() []string {
	var fields []string
	if m.addjobId != nil {
		fields = append(fields, script.FieldJobId)
	}
	if m.addusable != nil {
		fields = append(fields, script.FieldUsable)
	}
	if m.addrepeatInterval != nil {
		fields = append(fields, script.FieldRepeatInterval)
	}
	if m.addupdatedById != nil {
		fields = append(fields, script.FieldUpdatedById)
	}
	if m.addcreatedById != nil {
		fields = append(fields, script.FieldCreatedById)
	}
	if m.addregionId != nil {
		fields = append(fields, script.FieldRegionId)
	}
	if m.addmanagerId != nil {
		fields = append(fields, script.FieldManagerId)
	}
	if m.addmanagerGroupId != nil {
		fields = append(fields, script.FieldManagerGroupId)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ScriptMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case script.FieldJobId:
		return m.AddedJobId()
	case script.FieldUsable:
		return m.AddedUsable()
	case script.FieldRepeatInterval:
		return m.AddedRepeatInterval()
	case script.FieldUpdatedById:
		return m.AddedUpdatedById()
	case script.FieldCreatedById:
		return m.AddedCreatedById()
	case script.FieldRegionId:
		return m.AddedRegionId()
	case script.FieldManagerId:
		return m.AddedManagerId()
	case script.FieldManagerGroupId:
		return m.AddedManagerGroupId()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScriptMutation) AddField(name string, value ent.Value) error {
	switch name {
	case script.FieldJobId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddJobId(v)
		return nil
	case script.FieldUsable:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUsable(v)
		return nil
	case script.FieldRepeatInterval:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRepeatInterval(v)
		return nil
	case script.FieldUpdatedById:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedById(v)
		return nil
	case script.FieldCreatedById:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedById(v)
		return nil
	case script.FieldRegionId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRegionId(v)
		return nil
	case script.FieldManagerId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddManagerId(v)
		return nil
	case script.FieldManagerGroupId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddManagerGroupId(v)
		return nil
	}
	return fmt.Errorf("unknown Script numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ScriptMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ScriptMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ScriptMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Script nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ScriptMutation) ResetField(name string) error {
	switch name {
	case script.FieldProgram:
		m.ResetProgram()
		return nil
	case script.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case script.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case script.FieldJobId:
		m.ResetJobId()
		return nil
	case script.FieldHostname:
		m.ResetHostname()
		return nil
	case script.FieldCommand:
		m.ResetCommand()
		return nil
	case script.FieldComment:
		m.ResetComment()
		return nil
	case script.FieldUsable:
		m.ResetUsable()
		return nil
	case script.FieldRepeatInterval:
		m.ResetRepeatInterval()
		return nil
	case script.FieldUpdatedById:
		m.ResetUpdatedById()
		return nil
	case script.FieldCreatedById:
		m.ResetCreatedById()
		return nil
	case script.FieldRegionId:
		m.ResetRegionId()
		return nil
	case script.FieldManagerId:
		m.ResetManagerId()
		return nil
	case script.FieldManagerGroupId:
		m.ResetManagerGroupId()
		return nil
	case script.FieldStartTime:
		m.ResetStartTime()
		return nil
	case script.FieldEndTime:
		m.ResetEndTime()
		return nil
	}
	return fmt.Errorf("unknown Script field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ScriptMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ScriptMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ScriptMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ScriptMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ScriptMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ScriptMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ScriptMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Script unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ScriptMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Script edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op             Op
	typ            string
	id             *int32
	createdAt      *time.Time
	updatedAt      *time.Time
	username       *string
	password       *string
	realname       *string
	phone          *string
	email          *string
	role           *user.Role
	lastAccessed   *time.Time
	userGroupId    *int
	adduserGroupId *int
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*User, error)
	predicates     []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int32) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id int32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "createdAt" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *UserMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
}

// SetRealname sets the "realname" field.
func (m *UserMutation) SetRealname(s string) {
	m.realname = &s
}

// Realname returns the value of the "realname" field in the mutation.
func (m *UserMutation) Realname() (r string, exists bool) {
	v := m.realname
	if v == nil {
		return
	}
	return *v, true
}

// OldRealname returns the old "realname" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldRealname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRealname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRealname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRealname: %w", err)
	}
	return oldValue.Realname, nil
}

// ResetRealname resets all changes to the "realname" field.
func (m *UserMutation) ResetRealname() {
	m.realname = nil
}

// SetPhone sets the "phone" field.
func (m *UserMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *UserMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone resets all changes to the "phone" field.
func (m *UserMutation) ResetPhone() {
	m.phone = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetRole sets the "role" field.
func (m *UserMutation) SetRole(u user.Role) {
	m.role = &u
}

// Role returns the value of the "role" field in the mutation.
func (m *UserMutation) Role() (r user.Role, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldRole(ctx context.Context) (v user.Role, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *UserMutation) ResetRole() {
	m.role = nil
}

// SetLastAccessed sets the "lastAccessed" field.
func (m *UserMutation) SetLastAccessed(t time.Time) {
	m.lastAccessed = &t
}

// LastAccessed returns the value of the "lastAccessed" field in the mutation.
func (m *UserMutation) LastAccessed() (r time.Time, exists bool) {
	v := m.lastAccessed
	if v == nil {
		return
	}
	return *v, true
}

// OldLastAccessed returns the old "lastAccessed" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastAccessed(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastAccessed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastAccessed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastAccessed: %w", err)
	}
	return oldValue.LastAccessed, nil
}

// ResetLastAccessed resets all changes to the "lastAccessed" field.
func (m *UserMutation) ResetLastAccessed() {
	m.lastAccessed = nil
}

// SetUserGroupId sets the "userGroupId" field.
func (m *UserMutation) SetUserGroupId(i int) {
	m.userGroupId = &i
	m.adduserGroupId = nil
}

// UserGroupId returns the value of the "userGroupId" field in the mutation.
func (m *UserMutation) UserGroupId() (r int, exists bool) {
	v := m.userGroupId
	if v == nil {
		return
	}
	return *v, true
}

// OldUserGroupId returns the old "userGroupId" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUserGroupId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserGroupId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserGroupId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserGroupId: %w", err)
	}
	return oldValue.UserGroupId, nil
}

// AddUserGroupId adds i to the "userGroupId" field.
func (m *UserMutation) AddUserGroupId(i int) {
	if m.adduserGroupId != nil {
		*m.adduserGroupId += i
	} else {
		m.adduserGroupId = &i
	}
}

// AddedUserGroupId returns the value that was added to the "userGroupId" field in this mutation.
func (m *UserMutation) AddedUserGroupId() (r int, exists bool) {
	v := m.adduserGroupId
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserGroupId resets all changes to the "userGroupId" field.
func (m *UserMutation) ResetUserGroupId() {
	m.userGroupId = nil
	m.adduserGroupId = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.createdAt != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m.realname != nil {
		fields = append(fields, user.FieldRealname)
	}
	if m.phone != nil {
		fields = append(fields, user.FieldPhone)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.role != nil {
		fields = append(fields, user.FieldRole)
	}
	if m.lastAccessed != nil {
		fields = append(fields, user.FieldLastAccessed)
	}
	if m.userGroupId != nil {
		fields = append(fields, user.FieldUserGroupId)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldUsername:
		return m.Username()
	case user.FieldPassword:
		return m.Password()
	case user.FieldRealname:
		return m.Realname()
	case user.FieldPhone:
		return m.Phone()
	case user.FieldEmail:
		return m.Email()
	case user.FieldRole:
		return m.Role()
	case user.FieldLastAccessed:
		return m.LastAccessed()
	case user.FieldUserGroupId:
		return m.UserGroupId()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldRealname:
		return m.OldRealname(ctx)
	case user.FieldPhone:
		return m.OldPhone(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldRole:
		return m.OldRole(ctx)
	case user.FieldLastAccessed:
		return m.OldLastAccessed(ctx)
	case user.FieldUserGroupId:
		return m.OldUserGroupId(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldRealname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRealname(v)
		return nil
	case user.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldRole:
		v, ok := value.(user.Role)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case user.FieldLastAccessed:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastAccessed(v)
		return nil
	case user.FieldUserGroupId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserGroupId(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.adduserGroupId != nil {
		fields = append(fields, user.FieldUserGroupId)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldUserGroupId:
		return m.AddedUserGroupId()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldUserGroupId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserGroupId(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldRealname:
		m.ResetRealname()
		return nil
	case user.FieldPhone:
		m.ResetPhone()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldRole:
		m.ResetRole()
		return nil
	case user.FieldLastAccessed:
		m.ResetLastAccessed()
		return nil
	case user.FieldUserGroupId:
		m.ResetUserGroupId()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown User edge %s", name)
}
